---
id: 1578
title: 'LogfÃ¡jlok pokla 2. &#8211; MDC keretrendszer alatt'
date: '2017-05-13T18:03:10+02:00'
author: tacsiazuma
layout: post
guid: '{{ site.url }}/admin/?p=1578'
permalink: /2017/05/13/logfajlok-pokla-2-mdc-keretrendszer-alatt/
tie_post_bg:
    - ''
tie_post_color:
    - ''
tie_gallery_style:
    - slider
tie_link_url:
    - ''
tie_link_desc:
    - ''
tie_video_url:
    - ''
tie_embed_code:
    - ''
tie_audio_mp3:
    - ''
tie_audio_m4a:
    - ''
tie_audio_oga:
    - ''
tie_audio_soundcloud:
    - ''
tie_quote_author:
    - ''
tie_quote_link:
    - ''
tie_quote_text:
    - ''
tie_status_facebook:
    - ''
tie_status_twitter:
    - ''
newsphere-meta-content-alignment:
    - align-content-left
image: 'assets/uploads/2017/05/09213655/red-oak-log-2-scaled-e1578605838303.jpg'
categories:
    - Laravel
    - PHP
tags:
    - apache
    - laravel
    - log4php
    - logging
    - mdc
---

Az elÅ‘zÅ‘ [cikkben ]({{ site.url }}/2017/05/11/mit-tegyunk-ha-mar-elvesztunk-logfajlokban/)arrÃ³l volt szÃ³, hogy is tudjuk elszeparÃ¡lni az egyes logbejegyzÃ©seket az apache loggerÃ©vel. Mint kiderÃ¼lt, van hasonlÃ³ funkcionalitÃ¡s a monologban is, csak ott mÃ©g nem volt ekkora rÃ¡hatÃ¡sa Martin Fowlernek Ã©s tÃ¡rsainak, mert nem MDC nÃ©ven, hanem processor nÃ©ven tudunk belenyÃºlni Ã©s plusz informÃ¡ciÃ³kkal kiegÃ©szÃ­teni az egyes bejegyzÃ©seket. ElsÅ‘ kÃ¶rben a Laravelt fogjuk megvizsgÃ¡lni ezen szempontbÃ³l, mÃ©gpedig az 5.4-es verziÃ³jÃ¡t.

[![](assets/uploads/2017/05/red-oak-log-2-1024x685.jpg)](assets/uploads/2017/05/red-oak-log-2.jpg) Az imÃ©nti monologos dolog utÃ¡n persze hasznÃ¡lhatnÃ¡nk azt is, de abbÃ³l a szempontbÃ³l is tanulsÃ¡gos lehet a cikk, hogy mennyire kÃ¶nnyÅ± vagy Ã©pp nehÃ©z kicserÃ©lni egy ilyen dolgot. TelepÃ­tsÃ¼k elÅ‘szÃ¶r a Laravelt egy mappÃ¡ba:

```
composer create-project laravel/laravel "5.4"
```

ezutÃ¡n navigÃ¡ljunk bele Ã©s jÃ¶het a logger is a helyÃ©re:

```
composer require apache/log4php : "^2.3"
```

Most, hogy megvannak a dolgok, akkor jÃ¶het az, hogy bekonfigurÃ¡ljuk a LoggerMDC-t. De mÃ©gis hol tegyÃ¼nk ilyet? Mivel nem egy kÃ¼lÃ¶n csomagban akarjuk ezt megvalÃ³sÃ­tani, ezÃ©rt jelen esetben kerÃ¼ljÃ¶n az AppServiceProvider boot metÃ³dusÃ¡ba:

```
class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        \Logger::configure("config/logger.php");
        $logger = \Logger::getLogger("main");
        Log::swap($logger);
    }
```

Na akkor most [![](assets/uploads/2017/05/Alljunk_meg_egy_szora.png)  ](assets/uploads/2017/05/Alljunk_meg_egy_szora.png)

A bootstrap sorÃ¡n a kÃ¶vetkezÅ‘k tÃ¶rtÃ©nnek. ElÅ‘szÃ¶r is megadjuk a konfigurÃ¡ciÃ³ helyÃ©t az apache loggerÃ©nek. Ezt a Laravel Ã¡ltal mÃ¡r megszokott helyre tettÃ¼k, a `config` mappÃ¡ba, mindjÃ¡rt megnÃ©zzÃ¼k a tartalmÃ¡t is. Ha ez megtÃ¶rtÃ©nt, akkor a statikus factory-bÃ³l kikÃ©rÃ¼nk egy logger pÃ©ldÃ¡nyt. EzutÃ¡n jÃ¶n az igazi mÃ¡gia, amikor azt mondjuk a Log facade-nek, hogy ugyan cserÃ©lje mÃ¡r ki a facade mÃ¶gÃ¶tt talÃ¡lhatÃ³ objektumot arra, amit Ã¡tadunk. Ez elÃ©g veszÃ©lyes jÃ¡tszma, ugyanis nincs rÃ¡ garancia, hogy ami objektumot Ã¡tadunk, az kÃ©pes lesz ellÃ¡tni azt a feladatot, mint amire hivatott, lÃ©vÃ©n semmifÃ©le tÃ­pusellenÅ‘rzÃ©s nincs, nem kell interfÃ©szeknek megfelelnÃ¼nk, se semmi, ugyanis mindenfÃ©le `call` Ã©s `callStatic`-ekkel kerÃ¼l megoldÃ¡sra mindez. Viszont az igen nagy szerencse ebben az esetben, hogy a kÃ©t logger, a monolog Ã©s a log4php kÃ¶zel ugyanolyan metÃ³dusokkal van felvÃ©rtezve, ezÃ©rt a kÃ³dunkat nem nagyon tudjuk megfektetni, habÃ¡r ez a megoldÃ¡s kÃ¶zel sem szÃ©p. Most akkor nÃ©zzÃ¼k meg a konfigurÃ¡ciÃ³t:

```
return array(
    'appenders' => array(
        'default' => array(
            'class' => 'LoggerAppenderFile',
            'layout' => array(
                'class' => 'LoggerLayoutPattern',
                'params' => array(
                    'conversionPattern' => '%date [%logger] [%-5level] [%mdc{guid}] %msg%n'
                )
            ),
            'params' => array(
                'file' => 'storage/logs/laravel.log',
                'append' => true
            ),
        ),
    ),
    'rootLogger' => array(
        'appenders' => array('default'),
    )
);
```

Nagyban hasonlÃ­t az elÅ‘zÅ‘ cikkben Ã­rtakhoz, a fÃ¡jl elÃ©rÃ©si ÃºtjÃ¡t leszÃ¡mÃ­tva, amit ugyanis a laravel default logjÃ¡hoz Ã¡llÃ­tottunk be, hogy ez ne vÃ¡ltozzon. Akkor most jÃ¶n az, hogy hol kellene az MDC Ã©rtÃ©kÃ©t beÃ¡lÃ­tani? Nos ezt egy middlewareben kellene megejtenÃ¼nk, Ãºgyhogy hozzunk is lÃ©ttre egy UserAware middleware-t erre a cÃ©lra. Ez annyit fog csinÃ¡lni, hogy a sÃ¼tik kÃ¶zÃ¼l a guid-ot kiszedi Ã©s beÃ¡llÃ­tja az MDC-k kÃ¶zÃ©.

```
public function handle($request, \Closure $next)
{

    \LoggerMDC::put("guid",$request->cookie("laravel_session"));

    return $next($request);
}
```

Az egyszerÅ±sÃ©g kedvÃ©Ã©rt most a laravel session Ã©rtÃ©kÃ©t fogjuk hasznÃ¡lni, Ã­gy nem kell kÃ¼lÃ¶n sÃ¼tit lÃ©trehoznunk Ã©s beÃ¡llÃ­tgatnunk. Akkor mÃ¡r csak egy olyan route kell, ahol hasznÃ¡ljuk ezt a middleware-t. VegyÃ¼k fel a web-es middleware groupba mindezt a `app/Http/Kernel.php` - ban:

```
protected $middlewareGroups = [
    'web' => [
        \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\VerifyCsrfToken::class,
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
        UserAware::class
    ],
```

EzutÃ¡n minden `routes/web.php`-ben lÃ©trehozott route-ra Ã©rvÃ©nyes lesz ez a middleware is, Ã­gy nincs mÃ¡s dolgunk, mint a gyÃ¡ri welcome page-et kiegÃ©szÃ­teni:

```
Route::get('/', function () {
    Log::info("teszt");
    return view('welcome');
});
```

EzutÃ¡n ha meglÅ‘jÃ¼k a fÅ‘oldalt, mÃ¡r lÃ¡thatjuk is a logbejegyzÃ©seket:

```
2017-05-12T22:01:42+00:00 [main] [INFO] [WTWlh1oaFTpSO0tFzCMScpYZNkgtlQ8fKxPOeygk] teszt
```

Nem is volt olyan nehÃ©z, ugye? Viszont a megoldÃ¡s tovÃ¡bbra sem szÃ©p, de annak Ã©rdekÃ©ben, hogy generikus megoldÃ¡st hozzunk a rendszerbe (ezÃ¡ltal a kivÃ©telek is ezzel legyenek logolva), ami pl. kÃ©pes az exception-Ã¶k kezelÃ©sÃ©re is, sajnos le kell cserÃ©ljÃ¼k a loggert. Viszont mÃ¡gia ide vagy oda, a nap vÃ©gÃ©n nekÃ¼nk adott egy [Logger](https://github.com/apache/logging-log4php/blob/master/src/main/php/Logger.php) osztÃ¡lyunk, amire rÃ¡ akarunk hÃºzni egy [LoggerInterface](https://github.com/php-fig/log/blob/master/Psr/Log/LoggerInterface.php)-t. A Log facade az alÃ¡bbi statikus metÃ³dusokkal rendelkezik, amiket egy az egyben delegÃ¡l az elburkolt osztÃ¡ly nem-statikus metÃ³dusainak:

```
 Log::emergency($message);
 Log::alert($message);
 Log::critical($message);
 Log::error($message);
 Log::warning($message);
 Log::notice($message);
 Log::info($message);
 Log::debug($message);
```

TehÃ¡t egy az egyben megfelel a PSR LoggerInterface-nek. Sajnos az apache loggere nem felel meg ennek az interfÃ©sznek, Ãºgyhogy valamit tennÃ¼nk kell. Ha nem hisszÃ¼k el, prÃ³bÃ¡ljuk ki az emergency metÃ³dust:

```
Route::get('/', function () {
    Log::emergency("teszt");
    return view('welcome');
});
```

Bizony, csÃºnyÃ¡n elszÃ¡ll a dolog:

```
2017-05-13T10:39:42+00:00 [main] [ERROR] [] Symfony\Component\Debug\Exception\FatalThrowableError: Call to undefined method Logger::emergency()
```

Mondjuk az dÃ­csÃ©retes, hogy az errort ugyanÃºgy kilogoltuk ðŸ™‚

Mi is volt az a tervezÃ©si minta, ami kÃ©t nem kompatibilis interfÃ©sz Ã¡thidalÃ¡sÃ¡ra szolgÃ¡lt? Bizony, ez az [adapter]({{ site.url }}/2015/01/29/tervezesi-mintak-adapter-pattern/) lesz, ami erÅ‘sen [decorator]({{ site.url }}/2016/04/28/diszitsuk-fel-wrappert/) szagÃº is! Mivel nincs konkrÃ©t megfeleltetÃ©s, amikor swapeljÃ¼k az facade mÃ¶gÃ¶tti objektumot, ezÃ©rt lÃ©trehozunk egy adaptert, ami implementÃ¡lja a LoggerInterface-t Ã©s ennek a publikus metÃ³dusait mappeljÃ¼k Ã¡t az apache loggerÃ©re. Most erre kÃ¼lÃ¶n csomagot fogunk lÃ©trehozni, de az lenne a legjobb megoldÃ¡s, ha mÃ¡r valaki lÃ©trehozott volna Ã©s azt hasznÃ¡lnÃ¡nk, de abban nem lenne semmi izgalmas ðŸ™‚

Akkor keressÃ¼nk egy megfelelÅ‘ helyet erre Ã©s hozzunk lÃ©tre egy szÃ©p composer.json-t:

```
{
    "name": "letscodehu/monolog-log4php-bridge",
    "require": {
        "apache/log4php" : "2.3",
        "psr/log" : "^1.0"
    },
    "autoload" : {
      "psr-4" : {
       "Letscodehu\\" : "src/"
      }
    },
    "authors": [
        {
            "name": "Papp KrisztiÃ¡n",
            "email": "fejlesztes@letscode.hu"
        }
    ],
    "require-dev": {
    "phpunit/phpunit": "^6.1"
    }
}
```

SzÃ¼ksÃ©gÃ¼nk lesz az apache loggerÃ©re, valamint a PSR szabvÃ¡ny interfÃ©szekre, amit implementÃ¡l a monolog is. SzÃ¼ksÃ©gÃ¼nk lesz mÃ©g a PHPUnitra, hogy nÃ©hÃ¡ny egyszerÅ± teszttel lefedjÃ¼k azt. BelÅ‘jÃ¼k az autoloadert az `src` mappÃ¡ra Ã©s ezutÃ¡n mÃ¡r csak egy `composer install` kell Ã©s minden kÃ©szen Ã¡ll, hogy nekilÃ¡ssunk![![](assets/uploads/2017/05/heggesztes-4n.jpg)](assets/uploads/2017/05/heggesztes-4n.jpg)

Hozzunk lÃ©tre egy `LoggerAdapter` osztÃ¡lyt, ami egyelÅ‘re csak implementÃ¡lja a `LoggerInterface`-t, Ã¼res metÃ³dusokkal:

```
namespace Letscodehu\Logger;


use Psr\Log\LoggerInterface;

/**
 * Adapter class for wrapping Apache loggers to a PSR compliant Logger.
 * @author Krisztian Papp
 */
class LoggerAdapter implements LoggerInterface {

    /**
     * @var \Logger
     */
    private $logger;

    function __construct(\Logger $logger)
    {
        $this->logger = $logger;
    }

    public function emergency($message, array $context = array())
    {
        // TODO: Implement emergency() method.
    }

    public function alert($message, array $context = array())
    {
        // TODO: Implement alert() method.
    }

    public function critical($message, array $context = array())
    {
        // TODO: Implement critical() method.
    }

    public function error($message, array $context = array())
    {
        // TODO: Implement error() method.
    }

    public function warning($message, array $context = array())
    {
        // TODO: Implement warning() method.
    }

    public function notice($message, array $context = array())
    {
        // TODO: Implement notice() method.
    }

    public function info($message, array $context = array())
    {
        // TODO: Implement info() method.
    }

    public function debug($message, array $context = array())
    {
        // TODO: Implement debug() method.
    }

    public function log($level, $message, array $context = array())
    {
        // TODO: Implement log() method.
    }
}
```

Akkor jÃ¶jjenek hÃ¡t a tesztek, mert nem csak vaktÃ¡ban lÃ¶vÃ¶ldÃ¶zni akarunk, ha mÃ¡r itt a legÃºjabb PHPUnit szÃ¡munkra. Hozzunk lÃ©tre egy phpunit.xml-t a projekt gyÃ¶kerÃ©ben:

```
<?xml version="1.0" encoding="UTF-8"?>
<phpunit backupGlobals="false"
         backupStaticAttributes="false"
         bootstrap="vendor/autoload.php"
         colors="true"
         convertErrorsToExceptions="true"
         convertNoticesToExceptions="true"
         convertWarningsToExceptions="true"
         processIsolation="false"
         stopOnFailure="false">
    <testsuites>
        <testsuite name="Unit Tests">
            <directory suffix="Test.php">./tests</directory>
        </testsuite>
    </testsuites>
</phpunit>
```

Megadjuk neki a testsuite-unk helyÃ©t, ahol a `Test.php` vÃ©gzÅ‘dÃ©sÅ± fÃ¡jlokat fogja nekÃ¼nk felnyalni. BeÃ¡llÃ­tjuk a composer autoloaderÃ©t, mint bootstrap fÃ¡jl, valamint nÃ©hÃ¡ny alapbeÃ¡llÃ­tÃ¡st elvÃ©gzÃ¼nk.

EzutÃ¡n lÃ©trehozunk egy `LoggerAdapterTest.php`-t a tests mappÃ¡ban:

```
<?php


/**
 * Unit test for LoggerAdapter
 */
class LoggerAdapterTest extends \PHPUnit\Framework\TestCase {

}
```

Akkor most lehet elkezdeni vÃ©gre kÃ³dolni ðŸ™‚ ElÅ‘szÃ¶r is jÃ¶jjÃ¶n egy tÃ¶rÅ‘ teszt, ugye?

A teszt osztÃ¡lyunk setUp metÃ³dusÃ¡ba, ami minden teszt elÅ‘tt lefut, vegyÃ¼nk fel egy kÃ³drÃ©szletet, ami az adapterÃ¼nket lÃ©trehozza egy mock loggerrel:

```
private $mockLogger;
private $underTest;

public function setUp() {
    $this->mockLogger = $this->createMock(Logger::class);
    $this->underTest = new \Letscodehu\Logger\LoggerAdapter($this->mockLogger);
}
```

EzutÃ¡n jÃ¶jjÃ¶n egy teszt, elÅ‘szÃ¶r az info helyes mÅ±kÃ¶dÃ©sÃ©re:

```
/**
 * @test
 */
public function it_should_delegate_info_call() {
    // GIVEN
    $this->mockLogger->expects($this->once())->method("info")->with("test");
    // WHEN
    $this->underTest->info("test");
    // THEN
}
```

A korÃ¡bban Ã¡tadott mock-nak most megmondjuk, hogy egyszer meg fogjuk hÃ­vni az info metÃ³dusÃ¡t, mÃ©gpedig a "test" paramÃ©terrel. EzutÃ¡n meghÃ­vjuk tÃ©nylegesen Ã©s vÃ¡rjuk, hogy beigazolÃ³djon a dolog. Futtassuk le a teszteket a projekt gyÃ¶kerÃ©ben kiadva a

```
vendor/phpunit/phpunit/phpunit
```

parancsot.

```
There was 1 failure:

1) LoggerAdapterTest::it_should_delegate_info
Expectation failed for method name is equal to <string:info> when invoked 1 time(s).
Method was expected to be called 1 times, actually called 0 times.

FAILURES!
Tests: 1, Assertions: 1, Failures: 1.
```

TermÃ©szetesen failel, mivel mÃ©g nincs kÃ©sz az osztÃ¡lyunk. ZÃ¶ldÃ­tsÃ¼k ki a tesztet akkor!

```
public function info($message, array $context = array())
{
    $this->logger->info($message);
}
```

Ennyivel sikerÃ¼l is zÃ¶lddÃ© tenni a tesztet, viszont a gond ott van, hogy van itt egy $context paramÃ©ter is. Ez a Laravel defaultok hasznÃ¡latÃ¡val egy JSON encoded stringkÃ©nt jelenik meg, akkor egÃ©szÃ­tsÃ¼k ki a tesztÃ¼nket egy Ãºj metÃ³dussal:

```
/**
 * @test
 */
public function it_should_delegate_info_with_json_encoded_context() {
    // GIVEN
    $this->mockLogger->expects($this->once())->method("info")->with("test {\"test\":\"test\"}");
    // WHEN
    $this->underTest->info("test", ["test" => "test"]);
    // THEN
}
```

Ez termÃ©szetesen elszÃ¡ll, Ãºgyhogy Ã­rjuk meg a logikÃ¡t hozzÃ¡:

```
public function info($message, array $context = array())
{
    if (empty($context)) {
        $this->logger->info($message);
    } else {
        $this->logger->info(sprintf("%s %s", $message, json_encode($context)));
    }
}
```

Ezzel a teszt ki is lett zÃ¶ldÃ­tve. Az else Ã¡gban levÅ‘ rÃ©szt refaktorÃ¡lhatjuk egy kicsit, mert hasonlÃ³kÃ©ppen fogunk eljÃ¡rni az Ã¶sszes loglevel esetÃ©ben a context tartalmÃ¡val:

```
public function info($message, array $context = array())
{
    $this->logger->info($this->formatWithContext($message, $context));
}

private function formatWithContext($message, array $context)
{
    if (empty($context)) {
        $formatted = $message;
    } else {
        $formatted = sprintf("%s %s", $message, json_encode($context));
    }
    return $formatted;
}
```

Ãšjrafuttatjuk a teszteket Ã©s mivel zÃ¶ldek maradtak, ezÃ©rt mehetÃ¼nk tovÃ¡bb! Most nem fogok minden egyes metÃ³dusra kitÃ©rni, amiket csak Ã­gy tovÃ¡bbadunk, hanem azokra tÃ©rek ki, amik pl. nem lÃ©teznek. Ezeket az apache Logger::log metÃ³dusÃ¡n Ã¡t tudjuk majd elÃ©rni, aminek az elsÅ‘ paramÃ©tere lesz a trÃ¼kkÃ¶s szÃ¡munkra. Ahhoz, hogy Ãºj logszintet hozzunk lÃ©tre, egy meglÃ©vÅ‘t kell hasznÃ¡lnunk, ugyanis egy privÃ¡t konstruktorral meghiÃºsÃ­tottÃ¡k azon irÃ¡nyÃº terveinket, hogy szimplÃ¡n leÃ¶rÃ¶kÃ­tsÃ¼k a `LoggerLevel` osztÃ¡lyt, ennÃ©lfogva nÃ©mileg Ã¡tmappeljÃ¼k a dolgokat, Ã­gy a monolog `emergency` Ã©s `critical` loglevelbÅ‘l `fatal`-t alkotunk, a `notice`-bÃ³l pedig `info`-t.

A kÃ©sz csomag, a maga pÃ¡r fÃ¡jljÃ¡val [itt](https://github.com/letscodehu/monolog-log4php-bridge) talÃ¡lhatÃ³. Akkor vissza a Laravelhez! A composer.json-ben fel kell vegyÃ¼k a repositories kÃ¶zÃ© a github repot, mivel packagist-re nem kerÃ¼lt ki a dolog:

```
"repositories" : [
  {
    "type" : "vcs",
    "url" : "https://github.com/letscodehu/monolog-log4php-bridge"
  }
],
```

Valamint, mivel mÃ¡r az adaptert akarjuk behÃºzni, kicserÃ©lhetjÃ¼k az `apache/log4php`-t az adapter csomagjÃ¡ra a `require` szekciÃ³ban:

```
"letscodehu/monolog-log4php-bridge" : "1.0.0"
```

EzutÃ¡n pedig updateljÃ¼k a projektet:

```
composer update
```

EzutÃ¡n pedig az AppServiceProviderben Ã­rjuk kicsit Ã¡t a boot-ot:

```
$logger = \Logger::getLogger("main");
$loggerAdapter = new LoggerAdapter($logger);
Log::swap($loggerAdapter);
```

EzutÃ¡n pedig nÃ©zzÃ¼k meg Ãºjra azt az emergency-t, most rÃ¡adÃ¡skÃ©nt valami context-el:

```
Route::get('/', function () {
    Log::emergency("teszt", ["id" => "teszt"]);
    return view('welcome');
});
```

A logfÃ¡jlokban pedig:

```
2017-05-13T16:54:18+00:00 [main] [FATAL] [OfrSbJozpkVLZImqNj5LSldGqNMu7n0rsfW4tyJ4] teszt {"id":"teszt"}
```

TehÃ¡t sikerÃ¼lt Ã¡thidaljuk a problÃ©mÃ¡t, mondjuk nem a legszebb mÃ³dszerrel. A kÃ¶vetkezÅ‘ cikkben megnÃ©zzÃ¼k mindezt Symfony Ã©s Zend alatt is, Ã©s sorra kerÃ¼l vÃ©gre a Splunkos keresÃ©sre is!