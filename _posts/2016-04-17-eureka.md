---
id: 1092
title: Eureka!
date: '2016-04-17T12:46:29+02:00'
author: tacsiazuma
layout: post
guid: '{{ site.url }}/?p=1092'
permalink: /2016/04/17/eureka/
tie_post_bg:
    - ''
    - ''
tie_post_color:
    - ''
    - ''
tie_gallery_style:
    - slider
    - slider
tie_link_url:
    - ''
    - ''
tie_link_desc:
    - ''
    - ''
tie_video_url:
    - ''
    - ''
tie_embed_code:
    - ''
    - ''
tie_audio_mp3:
    - ''
    - ''
tie_audio_m4a:
    - ''
    - ''
tie_audio_oga:
    - ''
    - ''
tie_audio_soundcloud:
    - ''
    - ''
tie_quote_author:
    - ''
    - ''
tie_quote_link:
    - ''
    - ''
tie_quote_text:
    - ''
    - ''
tie_status_facebook:
    - ''
    - ''
tie_status_twitter:
    - ''
    - ''
dsq_needs_sync:
    - '1'
    - '1'
newsphere-meta-content-alignment:
    - align-content-left
image: 'assets/uploads/2016/04/09202114/microservices-aggregator-1024x528-1.png'
categories:
    - Architecture
    - Backend
    - Microservice
    - Node.js
tags:
    - architecture
    - backend
    - client
    - eureka
    - microservice
    - node
---

Az elm√∫lt p√°r cikkben igyekeztem meglovagolni √©n is azt a hype-ot, ami a microservice architekt√∫r√°val kapcsolatos, de eddig el√©gg√© elm√©leti megk√∂zel√≠t√©se volt a dolgoknak, √≠gy gondoltam most kicsit v√°ltok √©s egy saj√°t kis p√©ld√°t dobok √∂ssze, hogy szeml√©ltessem a dolgot.

Amire a cikkben l√©v≈ë p√©ld√°hoz sz√ºks√©g lesz:

- [docker](https://www.docker.com/) (err≈ël [itt]({{ site.url }}/2015/10/25/dokkolnam-dokkolnam/) olvashattok)
- n√©mi kaka√≥ a g√©pben, amin csin√°lj√°tok, mert p√°r szolg√°ltat√°st feldobunk r√° (nem, most nem AWS p√©lda lesz, de ig√©ny szerint majd csin√°lok azt is), n√©v szerint egy Eureka fog futni, 3x3 darab egyszer≈±bb Node alkalmaz√°s, 3 key-value store, meg 3 MySQL (sima, nem cluster).
- [Node ](https://nodejs.org/en/)√©s [npm](https://docs.npmjs.com/cli/install).
- Egy shell, ahol fel tudod tolni a sz√ºks√©ges initial SQL szerkezetet √©s dummy tartalmat (vagy myadmin, ha az jobban tetszik üôÇ )
- Ha lusta vagy g√©pelni, akkor p√©ldak√≥d let√∂lt√©s√©hez [git]({{ site.url }}/2015/02/22/a-git-tegylet/) üôÇ <figure aria-describedby="caption-attachment-1093" class="wp-caption aligncenter" id="attachment_1093" style="width: 670px">[![microservices-aggregator-1024x528](assets/uploads/2016/04/microservices-aggregator-1024x528-1024x528.png)](assets/uploads/2016/04/microservices-aggregator-1024x528.png)<figcaption class="wp-caption-text" id="caption-attachment-1093">Forr√°s: http://blog.arungupta.me/microservice-design-patterns/</figcaption></figure>

Akkor az els≈ë amire sz√ºks√©g√ºnk lesz, hogy √∂sszetartsuk a fenti rendszert, az az Eureka lesz, aminek a telep√≠t√©s√©vel √©s hasonl√≥kkal most minim√°lisan fogunk foglalkozni, mert Dockerben fogjuk azt futtatni, amivel a ber√∂ffent√©se leegyszer≈±s√∂dik egy szimpla

```
<pre data-language="shell">docker run -d --name eureka-server -p 32784:8080 netflixoss/eureka:1.1.142
```

-ra.

> **Akinek nem lenne tiszta mi is ez az Eureka:** Ez egy √∫n. service registry, ahova a k√ºl√∂nb√∂z≈ë service-eink beregisztr√°lnak, azt√°n meghat√°rozott id≈ëk√∂z√∂nk√©nt k√ºldenek √©letjelet magukr√≥l. Az eureka lesz az, amit azt√°n k√©rdezgetnek a service-ek, ha valamelyik m√°sik service hol- √©s mibenl√©t√©r≈ël akarnak inf√≥t. √çgy elker√ºlhet≈ë az, hogy a service-einkbe bele√©gess√ºk a t√∂bbiek el√©r√©s√©t, csup√°n a nev√ºkre van sz√ºks√©g, ami alapj√°n az eureka-t√≥l ki tudja annak el√©r√©s√©t k√©rni.

A fenti parancs leh√∫zza a dockerhubr√≥l az eureka image-√©t, elind√≠tja azt eureka-server n√©ven, m√©gpedig daemonk√©nt a h√°tt√©rben √©s a 8080-as bels≈ë portra a docker0 interface 32784-es portja fog mutatni. Kell neki egy kis id≈ë mire √©szhez t√©r, de kb. 1 perc m√∫lva m√°r le tudjuk tesztelni. Ha nem tudjuk, hogy hol is tal√°lhato a docker0 interface, akkor az ifconfig-al el≈ë tudjuk hal√°szni. Ha megvan, akkor n√©zz√ºk meg, hogy m≈±k√∂dik-e a dolog. Ind√≠tsunk egy GET k√©r√©st az /eureka/v2/apps endpointra. A v√°laszban a k√∂vetkez≈ët kellene kapjuk:

```
<applications>
 <versions__delta>1</versions__delta>
 <apps__hashcode></apps__hashcode>
</applications>
```

√úres, l√©v√©n m√©g semmi sincs felregisztr√°lva oda.

Akkor j√∂jjenek a MySQL-ek:

```
docker run -d -p 12805:3306 --name accounts_mysql -e MYSQL_ROOT_PASSWORD=password mysql:latest
docker run -d -p 12806:3306 --name products_mysql -e MYSQL_ROOT_PASSWORD=password mysql:latest
docker run -d -p 12807:3306 --name orders_mysql -e MYSQL_ROOT_PASSWORD=password mysql:latest
```

A fenti h√°rom kont√©nerben futnak majd elk√ºl√∂n√≠tve a h√°rom k√ºl√∂n service-t kiszolg√°l√≥ MySQL-ek. Alapb√≥l expose-olj√°k a 3306-os portot, amivel docker style √∂ssze is linkelhetn√©nk ≈ëket a service-ekkel, de most ennyire nem menn√©k bele. A l√©nyeg, hogy ezek is a 12805-12807-es portokon el√©rhet≈ëek lesznek a docker0 interface-en.

T√∂lts√ºk is fel dummy adatokkal ≈ëket! A sz√ºks√©ges SQL dumpok megtal√°lhat√≥ak a [repo](https://github.com/letscodehu/Eureka-test)-ban.

```
cat accounts.sql | mysql --host={DOCKER0_IF} --port=12805 --password=password
cat products.sql | mysql --host={DOCKER0_IF} --port=12806 --password=password
cat orders.sql | mysql --host={DOCKER0_IF} --port=12807 --password=password
```

Akkor most j√∂jj√∂n a cache r√©teg:

```
docker run -d -p 10564:6379 --name accounts-redis redis
docker run -d -p 10565:6379 --name products-redis redis
docker run -d -p 10566:6379 --name orders-redis redis
```

> Persze azt mindig tartsuk √©szben, hogy ezek nem k√∂telez≈ëen egyazon g√©pen helyezkednek el, most csak a p√©lda kedv√©√©rt van √≠gy

Akkor mostm√°r a data source r√©teg rendben, j√∂hetnek az alkalmaz√°sok, amik ezt haszn√°lj√°k!

Node.js-t fogunk haszn√°lni az egyszer≈±s√©g kedv√©√©rt, amihez ugye sz√ºks√©g lesz egy express-re, egy eureka, mysql, redis kliensre √©s indulhat is a menet!

Package.json tartalma:

```
{
  "name": "hello-eureka",
  "description": "Eureka test app",
  "version": "0.0.1",
  "private": true,
  "dependencies": {
    "express": "3.12.0",
    "eureka-js-client" : "2.4.0",
    "md5" : "2.*",
    "redis" : "2.6.0-1",
    "mysql" : "2.10.*"
  }
}
```

Ezzel m√°r le is tudjuk h√∫zni azt a p√°r f√ºgg≈ës√©get, ami nek√ºnk kell egy-egy service m≈±k√∂d√©s√©hez. Az aggreg√°tort √©s a load balancert majd k√ºl√∂n t√°rgyaljuk. Az egyszer≈±s√©g kedv√©√©rt, most egy igen egyszer≈± node app-ot rakunk √∂ssze, ami parancssori param√©ter alapj√°n d√∂nti el, hogy a 3 sql/redis du√≥b√≥l melyikb≈ël is fog kiszolg√°lni, valamint itt lesz a load-balancer √©s a view aggregator is, de √©rtelemszer≈±en ennyire nem egyszer≈± a helyzet a val√≥ √©letben üôÇ

Service.js:

```
<pre data-language="javascript">// a service t√≠pusa
var serviceType = process.argv.pop();

var port = 5000;

var express = require('express');
// eureka kliens√ºnk
var eureka = require("eureka-js-client").Eureka;
// csak az egyedi hostname miatt
var md5 = require("md5");

// redis
var redis = require("redis");
var mysql = require("mysql");

// config
var config = require("./config").config[serviceType];
// eureka configja
var euConfig = require("./config").config.eureka;


var redisClient = redis.createClient({
    "host" : config.redis.host,
    "port" : config.redis.port
});

var connection = mysql.createConnection({
    port    : config.mysql.port,
    host     : config.mysql.host,
    user     : config.mysql.username,
    password : config.mysql.password,
    database : config.mysql.database
});

connection.connect(function(err) {
    if (err) {
        console.error('error connecting: ' + err.stack);
        return;
    }
    console.log('connected as id ' + connection.threadId);
});

var app = express();

var euClient = new eureka({
    // application instance information
    instance: {
        app: config.serviceName,
        hostName: md5(Date.now()),
        ipAddr: process.env.DOCKER_HOST,
        port: process.env.DOCKER_PORT,
        vipAddress: 'jq.test.something.com',
        dataCenterInfo: {
            name: 'MyOwn'
        }
    },
    eureka: {
        // eureka server host / port
        host: euConfig.host,
        port: euConfig.port
    }
});
// beregisztr√°lunk az eurek√°ra √©s k√ºldj√ºk az √©letjeleket
euClient.start();

// ne vegy√ºnk p√©ld√°t a szerkezetr≈ël, az anonymous function-√∂ket ker√ºlj√ºk m√°skor
app.get('/', function (req, res) {
    // megless√ºk a cache-t
    redisClient.get("accounts", function(err, reply) {
        if (err != null || reply == null) {
    // nem vissz√ºk t√∫lz√°sba a dolgokat, csak a p√©lda kedv√©√©rt
            connection.query('SELECT * FROM ' + config.mysql.table, function(err, rows) {
                if (err) {
                    console.error('error connecting: ' + err.stack);
                    res.end();
                }
                console.log("sql-b≈ël");
                res.end(JSON.stringify(rows));
                redisClient.set("accounts", JSON.stringify(rows));
            });
            return;
        }
        console.log("redis-b≈ël");
        res.end(reply);
    });
});

app.listen(port);

module.exports = app;
```

Na most a fenti alkalmaz√°sunkat akkor elemezgess√ºk csak v√©gig! Beh√∫zzuk a sz√ºks√©ges f√ºgg≈ës√©geket √©s konfigur√°ci√≥t, azt√°n felregisztr√°lunk az eurek√°ra. Itt k√∂rnyezeti v√°ltoz√≥kat fogunk majd haszn√°lni, mert hab√°r az app a kont√©neren bel√ºl az 5000-es porton cs√ºcs√ºl, k√≠v√ºlr≈ël m√°sik porton √©s c√≠men fogjuk el√©rni. Ezeket a v√°ltoz√≥kat majd a docker-el fogjuk √°tadni. Sajnos m√©g nem tal√°ltam megold√°st, hogy a docker √°tadn√°-e a dolgokat a kont√©nernek, amivel megk√∂nny√≠thetn√© az √©letemet, de ha valaki tud ilyenr≈ël, az sz√≥ljon!

Nos ha be√©rkezik egy k√©r√©s a figyelt portra, akkor a hozz√°nk rendelt redis-b≈ël megpr√≥b√°ljuk el≈ëhal√°szni az adatokat, ha nem siker√ºlt, akkor pedig szimpl√°n lek√©rj√ºk az √∂sszeset SQL-b≈ël √©s elmentj√ºk a cache-be, k√©s≈ëbbi haszn√°latra. Pretty simple.

√ñnmag√°ban nem is a service lesz itt a l√©nyeg, sz√≥val ezt pr√≥b√°ltam a lehet≈ë legegyszer≈±bbre hagyni.

A haszn√°lt konfig (config.js):

```
var docker0 = "172.17.42.1"; // mivel minden a docker0-on cs√ºcs√ºl, √≠gy egyszer≈±bb

exports.config = {
    eureka : {
        host : docker0,
        port : 32784
    },
    aggregator : {
        serviceName : "aggregatorService"
    },
    accounts : {
        serviceName : "accountService",
        mysql : {
            host : docker0,
            port : 12805,
            table : "accounts",
            database : "account",
            "username" : "root",
            "password" : "password"
        },
        redis : {
            host : docker0,
            port : 10564
        }
    },
    orders : {
        serviceName : "orderService",
        mysql : {
            host : docker0,
            port : 12807,
            table : "orders",
            database : "order",
            "username" : "root",
            "password" : "password"
        },
        redis : {
            host : docker0,
            port : 10565
        }
    },
    products : {
        serviceName : "productService",
        mysql : {
            host : docker0,
            port : 12806,
            table : "products",
            database : "product",
            "username" : "root",
            "password" : "password"
        },
        redis : {
            host : docker0,
            port : 10566
        }
    }
};
```

Sz√©pen feldarabolva az egyes service-ekhez tartoz√≥ konfigur√°ci√≥k. Alapb√≥l mindenhova √≠gy adn√°nk meg az el√©r√©st, de most a service registry miatt nem kell annyira belemenn√ºnk.

Most, hogy a service-ek megvannak, nem √°rt beletenn√ºnk ≈ëket egy-egy kont√©nerbe. Ehhez sz√ºks√©g√ºnk lesz egy Dockerfile-ra:

```
FROM node:latest
MAINTAINER fejlesztes@letscode.hu
# set default workdir
WORKDIR /usr/src
# Add package.json to allow for caching
COPY package.json /usr/src/package.json
# Install app dependencies
RUN npm install
# Bundle app source and config
COPY config.js /usr/src/
COPY service.js /usr/src/
COPY load-balancer.js /usr/src/
COPY aggregator.js /usr/src/

# user to non-privileged user

USER nobody
# Expose the application port and run application
EXPOSE 5000
# Itt van az initial command
CMD ["node","service.js", "products"]
```

A fenti f√°jlt majd sz√ºks√©ges lesz m√≥dos√≠tanunk az egyes buildek el≈ëtt, mert a service.js-nek √°tadott param√©ter v√°ltozni fog majd, de most √≠rjuk be a k√∂vetkez≈ë parancsot:

```
<pre data-language="shell">docker build -t product-service .
```

Majd √≠rjuk √°t a CMD sor utols√≥ param√©ter√©t orders-re √©s futtassuk √∫jra:

```
<pre data-language="shell">docker build -t order-service .
```

Ezut√°n a param√©tert √≠rjuk √°t accounts-ra √©s √∫jra:

```
<pre data-language="shell">docker build -t account-service .
```

Most, hogy a h√°rom kis kiszolg√°l√≥ k√©sz van, j√∂jj√∂n az, ami egybevar√°zsolja a dolgokat, a view aggreg√°tor. Ez is egy el√©gg√© fapados cucc lesz, csak szeml√©ltetni az aggregator.js:

```
<pre data-language="javascript">var express = require('express');
// eureka kliens√ºnk
var eureka = require("eureka-js-client").Eureka;
// csak az egyedi hostname miatt
var md5 = require("md5");
var config = require("./config").config.aggregator;

// eureka configja
var euConfig = require("./config").config.eureka;

var http = require("http");

var app = express();

var hostName = md5(Date.now());
var euClient = new eureka({
    // application instance information
    instance: {
        app: config.serviceName,
        hostName: hostName,
        ipAddr: process.env.DOCKER_HOST,
        port: process.env.DOCKER_PORT,
        vipAddress: 'jq.test.something.com',
        dataCenterInfo: {
            name: 'MyOwn'
        }
    },
    eureka: {
        // eureka server host / port
        host: euConfig.host,
        port: euConfig.port
    }
});

euClient.start();

// a kezd≈ëindex
var i = 0;
// ez fog kidobni nek√ºnk egy instance-t a service-b≈ël
function getWorkingInstance(name) {
    var instances = euClient.getInstancesByAppId(name);
    var ret = [];

    if (instances) {
        // el≈ësz≈±r≈±nk, hogy csak a m≈±k√∂d≈ëek legyenek benne
        instances.forEach(function(instance) {
            if (instance.status !== "UP") {
                return;
            }
            ret.push({
                // csak a host √©s a port √©rdekel minket
                "host" : instance.ipAddr,
                "port" : instance.port.$
            });
        });
    }
    i = (i >= ret.length -1) ? 0 : (i + 1);
    return ret[i];
}

function getPromiseWithData(hostPortConfig, fieldName) {
    return new Promise(function(resolve, reject) {
        var request = http.get({
            "host":  hostPortConfig.host,
            "port": hostPortConfig.port,
            "path": "/"
        }, function(response) {
            var data = "";
            response.on("data", function(chunk) {
                data += chunk;
            });
            response.on("end", function() {
                var response = {
                    "key" : fieldName,
                    "data" :JSON.parse(data)
                };
                resolve(response);
            });
        });
        request.on("error", function(err) {
            reject(err);
        });

        request.end();
    });
}

app.get("/", function(req, res) {
    var productService = getWorkingInstance("productService");
    var orderService = getWorkingInstance("orderService");
    var accountService = getWorkingInstance("accountService");

    var product = getPromiseWithData(productService, "products");
    var account = getPromiseWithData(accountService, "accounts");
    var order = getPromiseWithData(orderService, "orders");

    Promise.all([product, account, order]).then(function(values) {
        var responseObj = {};
        values.forEach(function(item) {
            responseObj.hostId = hostName;
            responseObj[item.key] = item.data;
        });
        res.end(JSON.stringify(responseObj));
    }, function(err) {
        console.log(err);
        res.end(JSON.stringify({
            "error" : "Sorry, we cant fulfill your request!"
        }));
    });
});

app.listen(5000);

module.exports = app;
```

Szint√©n az 5000-es porton √ºl bel√ºl. Feliratkozik az Eurek√°ra, mint a t√∂bbiek. Ha be√©rkezik egy lek√©rdez√©s, akkor megh√≠vja az Eureka-t √©s kik√©ri a h√°rom service p√©ld√°nyait. Azoknak egy-egy lek√©r√©st ind√≠t √©s a v√©g√©n ezeket bev√°rva visszaad egy v√°laszt. Ha valamelyik hib√°ra fut, akkor hiba√ºzenettel t√©r vissza (igen, egy fokkal szofisztik√°ltabb megold√°s lenne, ha csak annak az egy service-nek az adatai hi√°nyozn√°nak a v√°laszb√≥l, tudom).

Ezut√°n a param√©tert √≠rjuk √°t az utols√≥ sort √≠gy √©s √∫jra:

```
CMD ["node","aggregator.js"]
```

```
<pre data-language="shell">docker build -t aggregator-service .
```

√âs a legv√©g√©n a load-balancer.js tartalma:

```
<pre data-language="javascript">var http = require('http');
// eureka kliens√ºnk
var eureka = require("eureka-js-client").Eureka;
// csak az egyedi hostname miatt
var md5 = require("md5");
// eureka configja
var euConfig = require("./config").config.eureka;

var euClient = new eureka({
    // application instance information
    instance: {
        app: "balancer",
        hostName: md5(Date.now()),
        ipAddr: '127.0.0.1',
        port: 5000,
        vipAddress: 'jq.test.something.com',
        dataCenterInfo: {
            name: 'MyOwn'
        }
    },
    eureka: {
        // eureka server host / port
        host: euConfig.host,
        port: euConfig.port
    }
});

euClient.start();

// a kezd≈ëindex
var i = 0;
// ez fog kidobni nek√ºnk egy instance-t a service-b≈ël
function getWorkingInstance(name) {
    var instances = euClient.getInstancesByAppId(name);
    var ret = [];

    if (instances) {
        // el≈ësz≈±r≈±nk, hogy csak a m≈±k√∂d≈ëek legyenek benne
        instances.forEach(function(instance) {
            if (instance.status !== "UP") {
                return;
            }
            ret.push({
                // csak a host √©s a port √©rdekel minket
                "host" : instance.ipAddr,
                "port" : instance.port.$
            });
        });
    }
    i = (i >= ret.length -1 ) ? 0 : (i + 1);
    return ret[i];
}

http.createServer(function (req, res) {
    var instance = getWorkingInstance("aggregatorService");
    var request = http.get({
        "host" : instance.host,
        "port" : instance.port
    },function(response) {
        response.pipe(res);
    });
    request.on("error", function() {
        res.end(JSON.stringify({
            "error" : "Unable to serve your request!"
        }));
    });

    request.end();
}).listen(5000);
```

√©s a hozz√° tartoz√≥ buildfile m√≥dos√≠t√°s:

```
CMD ["node","load-balancer.js"]
```

```
<pre data-language="shell">docker build -t balancer-service .
```

A fenti parancsok bele√©getik az aktu√°lis parancsok kimenet√©t egy image-be √©s azt megtag-elik a -t param√©terrel. Bizony√°ra megfigyelt√©tek a DOCKER\_HOST √©s DOCKER\_PORT k√∂rnyezeti v√°ltoz√≥t. Ezt majd a run parancs sor√°n kell √°tadnunk a kont√©nernek, ami alapj√°n helyes el√©r√©si √∫ttal regisztr√°l be az Eurek√°ba.

> Update: Erre a c√©lra szolg√°l a start.sh a projekt gy√∂ker√©ben, hogy ne kelljen egyes√©vel be√≠rk√°lni a dolgokat.

Na de most n√©zz√ºk, hogy mi is t√∂rt√©nik mikor ber√∂ffentj√ºk azt?

Elindul 3 product, 3 order √©s 3 account service. Most az adatok mibenl√©t√©re ne t√©rj√ºnk ki, csak random belepakoltam ezt-azt a t√°bl√°kba. Ezen fel√ºl van 2 view aggregator, ami a fenti 3 service k√∂z√ºl h√≠vogatja azokat, amik √©pp futnak. Azt√°n a h√°rmas v√°lasz√°t √∂sszes√≠tve t√©r vissza. Valamint lesz m√©g egy balancer, ami a k√©t aggreg√°tor k√∂z√ºl v√°lasztja ki az √©pp fut√≥t. Az√©rt Node.JS van itt haszn√°lva mert a k√©t aggreg√°tor is v√°ltoz√≥ c√≠men lehet, √≠gy Eureka-b√≥l k√©ri le azokat is. Ez persze megoldhat√≥ lenne Nginx [dinamikus rekonfigur√°l√°s√°val,](https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/) de az megint egy m√°sik sztori üôÇ

Viszont az az √©rz√©sem, hogy aki nem s≈±r≈±n foglalkozott ilyesmivel az kezdi elveszteni a fonalat, √≠gy j√∂jj√∂n egy √°bra az eg√©szr≈ël:

[![servicek](assets/uploads/2016/04/servicek-1024x756.png)](assets/uploads/2016/04/servicek.png)

L√°that√≥, hogy a rendszer p√°r r√©sze fix c√≠men van, m√≠g egy r√©sze dinamikus. Ez ut√≥bbiak miatt van sz√ºks√©g az Eurek√°ra igaz√°b√≥l. Akkor most, hogy mindenki leh√∫zta a rep√≥b√≥l a ccucot, n√©zz√ºk mi is t√∂rt√©nik, ha az SQL-ek beoktroj√°l√°sa ut√°n elind√≠tjuk azt a bizonyos start.sh-t!

Lebuildel≈ëdnek a docker image-ek, azt√°n pedig el is indulnak a p√©ld√°nyok. Ezut√°n ha mindent j√≥l csin√°ltunk √©s nem dobott valami hib√°t a rendszer, akkor ha megnyitjuk a b√∂ng√©sz≈ënkben a localhost:13344-et, akkor kih√°nyja el√©nk a view aggregate tartalm√°t, vagyis m≈±k√∂dik a dolog!

Na de mi alapj√°n is dolgozik mindez?

Ha r√°les√ºnk a **http://172.17.42.1:32784/eureka/v2/apps/aggregatorservice** -ra, akkor l√°thatjuk, hogy sz√©pen itt van XML-ben, minden info az aggregatorservice-r≈ël. Az Eureka [REST API-ja](https://github.com/Netflix/eureka/wiki/Eureka-REST-operations) sok inf√≥t tud nek√ºnk szolg√°ltatni √©s a kliensek is ezt haszn√°lj√°k √©rtelemszer≈±en. L√°that√≥ hogy h√°ny p√©ld√°ny van, milyen IP-n, porton, milyen st√°tusszal, de aki t√∂bbet szeretne err≈ël megtudni, annak [itt](https://github.com/Netflix/eureka/wiki) a komplett doksi.

```
<pre data-language="html"><application>
 <name>AGGREGATORSERVICE</name>
 <instance>
 <hostName>dd2a1d15f95e7b9c6026b5a70fcd07d3</hostName>
 <app>AGGREGATORSERVICE</app>
 <ipAddr>172.17.42.1</ipAddr>
 <status>UP</status>
 <overriddenstatus>UNKNOWN</overriddenstatus>
 <port enabled="true">13343</port>
 <securePort enabled="false">7002</securePort>
 <countryId>1</countryId>
 <dataCenterInfo class="com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo">
 <name>MyOwn</name>
 
 </dataCenterInfo>
 <leaseInfo>
 <renewalIntervalInSecs>30</renewalIntervalInSecs>
 <durationInSecs>90</durationInSecs>
 <registrationTimestamp>1460892987340</registrationTimestamp>
 <lastRenewalTimestamp>1460893497976</lastRenewalTimestamp>
 <evictionTimestamp>0</evictionTimestamp>
 <serviceUpTimestamp>1460892987238</serviceUpTimestamp>
 
 </leaseInfo>
 <metadata class="java.util.Collections$EmptyMap"/>
 <vipAddress>jq.test.something.com</vipAddress>
 <isCoordinatingDiscoveryServer>false</isCoordinatingDiscoveryServer>
 <lastUpdatedTimestamp>1460892987340</lastUpdatedTimestamp>
 <lastDirtyTimestamp>1460892987237</lastDirtyTimestamp>
 <actionType>ADDED</actionType>
 
 </instance>
 <instance>
 <hostName>d1e74f559e3a1766bab29d011fc3614e</hostName>
 <app>AGGREGATORSERVICE</app>
 <ipAddr>172.17.42.1</ipAddr>
 <status>UP</status>
 <overriddenstatus>UNKNOWN</overriddenstatus>
 <port enabled="true">13342</port>
 <securePort enabled="false">7002</securePort>
 <countryId>1</countryId>
 <dataCenterInfo class="com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo">
 <name>MyOwn</name>
 
 </dataCenterInfo>
 <leaseInfo>
 <renewalIntervalInSecs>30</renewalIntervalInSecs>
 <durationInSecs>90</durationInSecs>
 <registrationTimestamp>1460892986340</registrationTimestamp>
 <lastRenewalTimestamp>1460893496975</lastRenewalTimestamp>
 <evictionTimestamp>0</evictionTimestamp>
 <serviceUpTimestamp>1460892986312</serviceUpTimestamp>
 
 </leaseInfo>
 <metadata class="java.util.Collections$EmptyMap"/>
 <vipAddress>jq.test.something.com</vipAddress>
 <isCoordinatingDiscoveryServer>false</isCoordinatingDiscoveryServer>
 <lastUpdatedTimestamp>1460892986340</lastUpdatedTimestamp>
 <lastDirtyTimestamp>1460892986311</lastDirtyTimestamp>
 <actionType>ADDED</actionType>
 
 </instance>
</application>
```

Persze az Eureka √∂nmag√°ban m√©g nem jelent semmit, mert j√∂n az, ami az ilyen rendszerek l√©nyege.. Mi van akkor, ha lehalnak a service-eink?:) Na de err≈ël majd legk√∂zelebb!

> A p√©ld√°ban szerepl≈ë f√°jlok megtal√°lhat√≥ak [githubon](https://github.com/letscodehu/Eureka-test).